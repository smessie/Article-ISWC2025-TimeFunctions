<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">It&#39;s About Time: Time Functions for Comparing Partial and Floating Time Literals in SPARQL</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="It's About Time: Time Functions for Comparing Partial and Floating Time Literals in SPARQL">
  <meta name="citation_author" content="Ieben, Smessaert" />
  <meta name="citation_author" content="Julián, Rojas Meléndez" />
  <meta name="citation_author" content="Pieter, Colpaert" />
  
  <meta name="citation_publication_date" content="2025/09/11" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="its-about-time-time-functions-for-comparing-partial-and-floating-time-literals-in-sparql">It’s About Time: Time Functions for Comparing Partial and Floating Time Literals in SPARQL</h1>

  <ul id="authors">
    <li><a id="author-name" rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://smessaert.be/" typeof="foaf:Person schema:Person" resource="https://smessaert.be/#me"><span class="first-name">Ieben</span> Smessaert</a></li>
    <li><a id="author-name" rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://julianrojas.org/" typeof="foaf:Person schema:Person" resource="https://julianrojas.org/#me"><span class="first-name">Julián</span> Rojas Meléndez</a></li>
    <li><a id="author-name" rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://pietercolpaert.be/" typeof="foaf:Person schema:Person" resource="https://pietercolpaert.be/#me"><span class="first-name">Pieter</span> Colpaert</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
            Department of Electronics and Information Systems, Ghent University - imec, Ghent, Belgium</li>
  </ul>

</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context:      Why the need is so pressing or important -->
      <p>Working with temporal data on the Semantic Web remains challenging due to SPARQL’s limited support for comparing time literals of different data types and handling floating times without explicit time zones.
<!-- Need:         Why something needed to be done at all -->
These issues are especially problematic when dealing with partial time literals (such as <code>xsd:date</code>, <code>xsd:gYearMonth</code>, or <code>xsd:gYear</code>) and floating times, both of which are common in real-world knowledge graphs like Wikidata.
<!-- Task:         What was undertaken to address the need -->
To showcase the relevance and urgency of the problem, we gathered and reviewed existing discussions, specifications, draft proposals, and examples from deployed knowledge graphs, providing a consolidated starting point for further community dialogue.
<!-- Object:       What the present document does or covers -->
We then proposed a solution in the form of a set of SPARQL extension functions—<strong>Time Functions</strong>—designed to reinterpret time literals as time intervals, enabling consistent and type-agnostic temporal comparisons.
<!-- Findings:     What the work done yielded or revealed -->
These functions are formally described using the Function Ontology (FnO), and implemented in the Comunica query engine, with a publicly available demo application that allows users to interactively explore and test the functions.
<!-- Conclusion:   What the findings mean for the audience -->
The demo includes curated example queries that highlight both the limitations of existing SPARQL behavior and how the Time Functions enable more accurate filtering and sorting of temporal data.
<!-- Perspectives: What the future holds, beyond this work -->
In addition to providing a technical proposal, we advocate for improved temporal data publishing practices, urging data providers to use accurate data types and explicit time zones to support reliable temporal reasoning in the open-world context of RDF.</p>

      <p><span id="keywords" rel="schema:about"><strong class="title">Keywords</strong>
<a href="https://en.wikipedia.org/wiki/SPARQL" resource="http://dbpedia.org/resource/SPARQL">SPARQL</a>,
time literals,
extension functions,
partial times,
floating times
</span></p>

      <p><span id="demo" rel="schema:url"><strong class="title">Demo:</strong>
<a href="https://smessie.github.io/TimeFunctions-SPARQL-Editor/">https:/​/​smessie.github.io/TimeFunctions-SPARQL-Editor/</a></span></p>

      <p><span id="canonical" rel="schema:url"><strong class="title">Canonical version:</strong>
<a href="https://smessie.github.io/Article-ISWC2025-TimeFunctions/">https:/​/​smessie.github.io/Article-ISWC2025-TimeFunctions/</a></span></p>

      <p><span class="printonly firstpagefooter">
<span class="firstpagefootertop"> </span>
<span class="footnotecopyright">
<span style="font-style:italic">ISWC 2025 Companion Volume, November 2–6, 2025, Nara, Japan</span><br />
<img src="img/mail.png" width="12px" style="vertical-align: -2px;" /> <a href="mailto:ieben.smessaert@ugent.be">ieben.smessaert@ugent.be</a> (I. Smessaert); <a href="mailto:julianandres.rojasmelendez@ugent.be">julianandres.rojasmelendez@ugent.be</a> (J. Rojas); <a href="mailto:pieter.colpaert@ugent.be">pieter.colpaert@ugent.be</a> (P. Colpaert)<br />
<img src="img/orcid.svg" width="12px" style="vertical-align: -2px;" /> <a href="https://orcid.org/0009-0004-5281-0723">0009-0004-5281-0723</a> (I. Smessaert); <a href="https://orcid.org/0000-0002-6645-1264">0000-0002-6645-1264</a> (J. Rojas); <a href="https://orcid.org/0000-0001-6917-2167">0000-0001-6917-2167</a> (P. Colpaert)<br />
<img src="img/cc-by.png" width="50px" style="vertical-align: middle;" /><span style="font-size: 0.75em"> © 2025 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).</span><br />
</span>
</span></p>
    </div>
</section>


<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Introduction</h2>

        <p>Temporal literals are common in many datasets on the Semantic Web.
SPARQL, the standard query language for RDF, is frequently used to query, filter, and compare such temporal information.
However, current support for comparing and reasoning over time-related literals in SPARQL is limited, especially when it comes to <em>partial time literals</em> (e.g., <code>xsd:gYear</code>, <code>xsd:gYearMonth</code>, <code>xsd:date</code>) and <em>floating times</em> (i.e., time literals without explicit time zones).</p>

        <p>Although <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2025/WD-rdf12-concepts-20250704/">the RDF 1.1 standard</a> <span class="references">[<a href="#ref-1">1</a>]</span> recommends the use of various built-in XML Schema temporal data types (e.g., <code>xsd:dateTime</code>, <code>xsd:date</code>, and <code>xsd:gYearMonth</code>), the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#OperatorMapping">operator mappings from SPARQL 1.1</a> <span class="references">[<a href="#ref-2">2</a>]</span> define comparison semantics only for literals of the same data type.
Cross-datatype comparisons (e.g., comparing an <code>xsd:date</code> with an <code>xsd:dateTime</code>) are not defined, and existing SPARQL engines and</p>

        <p><span class="placeholder printonly">
<span style="display: block; height: 12em;"></span>
<!-- This is a dummy placeholder -->
</span></p>

        <p>querying frameworks such as Virtuoso, BlazeGraph, and Comunica return false or empty results in these cases, even if the date parts of the literals are comparable.</p>

        <p>This issue becomes problematic in large-scale, real-world knowledge graphs like Wikidata, where users can specify date precision (e.g., year, month, day) when entering temporal data.
Its SPARQL endpoint, however, returns fully qualified <code>xsd:dateTime</code> values without indicating the original precision.
For example, a historical event entered as <code>27th century BCE</code> may appear as such in the user interface, but is internally represented and queryable only as <code>"−2650-01-01T00:00:00Z"^^xsd:dateTime</code>.
This loss of precision in the queryable data undermines temporal reasoning and can produce misleading query results, such as asserting that this historical event happened in the month of January.</p>

        <p>Another critical challenge arises with <em>floating times</em>, which are time literals that lack time zone information.
A literal like <code>"2025-08-01T12:00:00"^^xsd:dateTime</code> can be interpreted differently depending on the context, or may be wrongly adjusted to the user’s local time zone.
This ambiguity makes consistent comparison and sorting unreliable.
While the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/timezone/">W3C Group Draft Note on Working with Time and Timezones</a> <span class="references">[<a href="#ref-3">3</a>]</span> recommends treating such floating times as UTC by default, this approach is insufficient in the open and distributed context of the Semantic Web, where data originates from diverse sources with potentially different implicit time zone assumptions.
As discussed in the GitHub issue regarding implicit time zones in SPARQL<sup id="fnref:IssueImplicitTimeZoneComparisonSorting"><a href="#fn:IssueImplicitTimeZoneComparisonSorting" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, it is problematic to consider floating times from different sources as equal because they can represent different time instants and thus have different implicit time zones.</p>

        <p>A more robust approach is to treat all temporal literals—particularly floating and partial ones—as time intervals, bounded by their earliest and latest possible interpretations.
For example, a floating time can be represented by the time interval it could occupy across the full range of legal time zone offsets (−14:00 to +14:00, as per <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes Second Edition</a> <span class="references">[<a href="#ref-4">4</a>]</span>).
This perspective enables meaningful comparison between floating, partial, and fully-qualified time literals by aligning them to their temporal bounds rather than requiring exact matches.</p>

        <p>Despite the growing interest in temporal reasoning on knowledge graphs, e.g., in works such as Soulard et al. 2025 <span class="references">[<a href="#ref-5">5</a>]</span>, issues around time zones and floating times are rarely addressed explicitly.
Moreover, while enhancement proposals like SEP-0002<sup id="fnref:SEP-0002"><a href="#fn:SEP-0002" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> improve SPARQL’s handling of date-time arithmetic, they do not cover cross-type comparison or floating time semantics.</p>

        <p>This paper aims to highlight these overlooked issues and present a concrete, extensible solution.
We propose a set of SPARQL extension functions—called <em>Time Functions</em>—that enable comparison across different temporal data types, interpretation of floating and partial times as intervals, and consistent and explainable time-based filtering and sorting.</p>

        <p>The remainder of this paper is structured as follows.
<a href="#functions">Section 2</a> introduces the proposed SPARQL extension functions for time handling, along with their formal semantics.
Subsequently, <a href="#demo">Section 3</a> presents a demo application showcasing how these functions enable richer and more accurate temporal queries over RDF data.
Finally, <a href="#conclusion">Section 4</a> concludes with a discussion of how Time Functions address the limitations of SPARQL for temporal reasoning, highlights their relevance for future standardization, and encourages improved temporal data publishing practices.</p>

        <p><span class="placeholder printonly">
<span style="display: block; height: 2em;"></span>
<!-- This is a dummy placeholder -->
</span></p>

      </div>
</section>

  <section id="functions" inlist="" rel="schema:hasPart" resource="#functions">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Time Functions</h2>

        <p>To address the limitations of SPARQL when dealing with temporal data, particularly the inability to compare partial or floating time literals, we propose a set of SPARQL extension functions called <strong>Time Functions</strong>.
These functions allow for consistent, meaningful comparison and reasoning over heterogeneous temporal literals by interpreting them as <strong>time intervals</strong>.</p>

        <p>The formal specification and accompanying ontology for these functions are available at <a href="https://w3id.org/time-fn">https:/​/​w3id.org/time-fn</a>.
The ontology uses the namespace <code>https:/​/​w3id.org/time-fn#</code> with the recommended prefix <code>tfn:</code>.
This specification defines the semantics of each function and provides an ontology for integrating time-aware logic into SPARQL queries.
The ontology relies on the Function Ontology (FnO) <span class="references">[<a href="#ref-6">6</a>]</span> to formally describe the semantics, inputs, and outputs of each function.
FnO provides a reusable and machine-readable vocabulary for specifying function metadata, well-suited for describing SPARQL extension functions.
This approach aligns with Semantic Web best practices and mirrors GeoSPARQL’s extension function set defined using FnO<sup id="fnref:GeoSPARQLFunctions"><a href="#fn:GeoSPARQLFunctions" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>.
By adopting this method, the Time Functions can be consistently documented, discovered, and potentially reused by other tools and specifications.</p>

        <h3 id="motivation-and-design">Motivation and Design</h3>

        <p>Time Functions treats all temporal literals as time intervals, interpreted as the range of time they could represent based on their earliest and latest possible interpretations. 
For instance, a literal <code>"2025-08"^^xsd:gYearMonth</code> spans from August 1st (<code>"2025-08-01T00:00:00-14:00"^^xsd:dateTime</code>) to August 31st (<code>"2025-08-31T23:59:59+14:00"^^xsd:dateTime</code>).
As discussed in <a href="#introduction">Section 1</a>, the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">W3C XML Schema Recommendation</a> <span class="references">[<a href="#ref-4">4</a>]</span> is followed to interpret floating date-time values as intervals that encompass all possible time zone offsets, using the full ±14:00 hour range, rather than defaulting to a specific time zone like UTC.</p>

        <p>By shifting from point-based to interval-based reasoning, these functions enable meaningful comparisons across data types, handle ambiguities introduced by missing time zones or precision, and make temporal filtering in SPARQL more reliable and consistent.</p>

        <h3 id="overview-of-time-functions">Overview of Time Functions</h3>

        <p>The current Time Functions include five core functions:</p>

        <ul>
          <li><strong>tfn:periodMinInclusive(?timeLiteral)</strong>: Returns the inclusive lower bound of the time period represented by the given temporal literal, as an <code>xsd:dateTime</code>. For example, for <code>"2025-08"^^xsd:gYearMonth</code>, it returns <code>"2025-08-01T00:00:00.000+14:00"^^xsd:dateTime</code>.</li>
          <li><strong>tfn:periodMaxInclusive(?timeLiteral)</strong>: Returns the inclusive upper bound of the time period represented by the given temporal literal. For the same example, it returns <code>"2025-08-31T23:59:59.999-14:00"^^xsd:dateTime</code>.</li>
          <li><strong>tfn:periodMinExclusive(?timeLiteral)</strong>: Returns the exclusive lower bound of the time period. This is particularly useful for defining open-ended or non-overlapping intervals in filtering logic. For the same example, it returns <code>"2025-07-31T23:59:59.999+14:00"^^xsd:dateTime</code>.</li>
          <li><strong>tfn:periodMaxExclusive(?timeLiteral)</strong>: Returns the exclusive upper bound of the time period. For the same example, it returns <code>"2025-09-01T00:00:00.000-14:00"^^xsd:dateTime</code>.</li>
          <li><strong>tfn:bindDefaultTimezone(?timeLiteral, ?timeZone)</strong>: For a given floating time literal, this function returns a new literal of the same type with the specified time zone bound. If the literal already includes a time zone, no default time zone needs to be bound to it, and it is returned unchanged. For the same example, it returns <code>"2025-08+02:00"^^xsd:gYearMonth</code> when bound to the <code>+02:00</code> time zone.
The function aligns with the approach proposed in <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/timezone/">Working with Time and Timezones</a> <span class="references">[<a href="#ref-3">3</a>]</span>, which recommends interpreting floating times as UTC by default.
However, it also supports more flexible, context-specific interpretations by allowing users to explicitly specify an alternative time zone.
Caution is advised when applying this function across data from heterogeneous sources, as there is no universally correct default time zone.
Nevertheless, the function enables binding a default time zone retrieved dynamically from the dataset itself.
For example, a SERVICE clause may be used to ensure that the time zone is sourced from the same dataset or endpoint as the time literal, preserving consistency within federated queries.
An example of such a query is included in the demo application, showcasing how default time zones can be retrieved and applied dynamically based on the queried data source.</li>
        </ul>

        <h3 id="use-cases">Use Cases</h3>

        <p>The Time Functions are applicable in a wide range of practical scenarios. When comparing dates of different data types, such as matching an <code>xsd:dateTime</code> with an <code>xsd:date</code>, the functions allow both values to be interpreted as intervals and compared accordingly.
This is particularly useful in knowledge graphs where schema constraints are loose and data often lacks uniform temporal granularity.</p>

        <p>Floating time literals pose challenges in distributed and heterogeneous datasets. Without a defined time zone, their interpretation is ambiguous, leading to incorrect comparisons or missed matches.
Time Functions make it possible to consistently bind a default time zone where appropriate or interpret the literal as an interval that spans all possible time zones, depending on the application’s needs.</p>

        <p>These functions also support more advanced temporal logic, such as detecting overlaps between time periods, validating temporal boundaries, and improving sorting behavior.
In knowledge graphs like Wikidata, where date precision is user-defined but not preserved in SPARQL query results, Time Functions allow users to reconstruct and reason about the intended temporal scope of such data.
More generally, they provide a principled foundation for integrating diverse temporal representations in SPARQL queries, enabling more accurate and expressive querying of temporal knowledge.</p>

      </div>
</section>

  <section id="demo" inlist="" rel="schema:hasPart" resource="#demo">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Demo</h2>

        <p>To illustrate the practical utility of the Time Functions, we developed an online demo application, available at <a href="https://smessie.github.io/TimeFunctions-SPARQL-Editor/">https:/​/​smessie.github.io/TimeFunctions-SPARQL-Editor/</a>.
The application is a lightweight SPARQL query editor that allows users to experiment interactively with the Time Functions described in <a href="#functions">Section 2</a>.</p>

        <p>Users can write and execute SPARQL queries, demonstrating how the Time Functions can address limitations in standard SPARQL when comparing partial or floating time literals.
Under the hood, the demo runs on the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica query engine</a> <span class="references">[<a href="#ref-7">7</a>]</span>, which has been extended<sup id="fnref:extensionImplementation"><a href="#fn:extensionImplementation" class="footnote" rel="footnote" role="doc-noteref">4</a></sup> to support these custom SPARQL extension functions.
The query interface itself is powered by the open-source YASQE editor<sup id="fnref:Yasqe"><a href="#fn:Yasqe" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>, which offers features such as syntax highlighting and autocompletion.</p>

        <figure class="screen-only">
 <iframe src="https://smessie.github.io/TimeFunctions-SPARQL-Editor/" style="width: 100%; height: 95vh;"></iframe>
 <figcaption>
            <p><strong>Fig. 1:</strong> Demo app with example SPARQL queries that demonstrate the use of the proposed Time Functions.</p>
          </figcaption>
</figure>

        <figure id="fig:default-query" class="halfwidth printonly">
 <img src="img/demo-default-query.png" alt="[Demo app with default query comparing an `xsd:date` to an `xsd:dateTime` yielding no results.]" />
 <figcaption>
            <p><span class="label">Fig. 1:</span> Demo app with default query comparing an <code>xsd:date</code> to an <code>xsd:dateTime</code> yielding no results.</p>
          </figcaption>
</figure>

        <figure id="fig:rewritten-query" class="halfwidth right printonly">
 <img src="img/demo-rewritten-query.png" alt="[Demo app with query using Time Functions to compare an `xsd:date` to an `xsd:dateTime`, yielding expected results.]" />
 <figcaption>
            <p><span class="label">Fig. 2:</span> Demo app with query using Time Functions to compare an <code>xsd:date</code> to an <code>xsd:dateTime</code>, yielding expected results.</p>
          </figcaption>
</figure>

        <p>The application includes example queries that highlight common pitfalls when working with time literals in SPARQL, as well as how the Time Functions can be used to resolve them.
<span class="printonly">
<a href="#fig:default-query">Fig. 1</a> shows a screenshot of the demo with a query that compares an <code>xsd:date</code> to an <code>xsd:dateTime</code>.
</span>
<span class="screen-only">
Fig. 1 includes a demo with a query “Publications at Bob Evnen’s birthdate” that compares an <code>xsd:date</code> to an <code>xsd:dateTime</code>.
</span>
Since SPARQL does not support comparisons between these types, the query yields no results—even though the date components are logically comparable.
<span class="printonly">
In <a href="#fig:rewritten-query">Fig. 2</a>, the same query is rewritten using the Time Functions to map both literals to their corresponding time intervals.
</span>
<span class="screen-only">
Clicking the button again rewrites the query using Time Functions to map both literals to their corresponding time intervals.
</span>
This allows for a meaningful comparison, and the query returns the expected result.</p>

      </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusion</h2>

        <p>In this paper, we have highlighted an important gap in the current processing of SPARQL queries dealing with temporal data.
This gap includes the inability to directly compare logically comparable data types such as <code>xsd:date</code> and <code>xsd:dateTime</code>, as well as potential ambiguity when dealing with floating time literals, especially in federated or heterogeneous data settings.
Moreover, current data modeling practices further complicate temporal reasoning: for instance, Wikidata represents imprecise time periods such as “27th century BCE” using a single <code>xsd:dateTime</code> literal (e.g., “-2650-01-01T00:00:00Z”), thereby flattening a broad time range into a misleading instant.
These challenges highlight a broader need for improved temporal data publishing practices: data should be expressed using accurate data types that reflect temporal granularity, and time zones should be made explicit wherever possible to avoid implicit and potentially conflicting assumptions.</p>

        <p>To address these limitations, we proposed a set of SPARQL extension functions, <strong>Time Functions</strong>, which reinterpret time literals as time intervals, enabling consistent and type-agnostic comparisons.
These functions support partial dates, floating times, and even cross-type comparisons by interpreting each time literal as a bounded interval, which can then be compared meaningfully using SPARQL.
Additionally, a function for binding a default time zone enables explicit handling of floating times in a configurable way.
These functions are formally specified using FnO, following established practices such as those in GeoSPARQL, and are implemented in a demo application using the Comunica query engine.
Our demonstrator provides an interactive environment to explore the functions in action and illustrates how they resolve common pitfalls in temporal querying.</p>

        <p>While the functions offer an immediate and practical solution, they are also intended to contribute to the broader discussion around improving temporal reasoning in the upcoming SPARQL 1.2 and beyond.
By surfacing the challenges and demonstrating a viable path forward, we hope this work sparks further standardization efforts and community feedback.</p>

      </div>
</section>

</main>

<footer>
  <section>
<div datatype="rdf:HTML" property="schema:description">
        <p><br /></p>

        <h2 id="endnotes">Endnotes</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:IssueImplicitTimeZoneComparisonSorting">
      <p><a href="https://github.com/w3c/sparql-query/issues/116">https:/​/​github.com/w3c/sparql-query/issues/116</a> <a href="#fnref:IssueImplicitTimeZoneComparisonSorting" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:SEP-0002">
      <p><a href="https://github.com/w3c/sparql-dev/blob/main/SEP/SEP-0002/sep-0002.md">https:/​/​github.com/w3c/sparql-dev/blob/main/SEP/SEP-0002/sep-0002.md</a> <a href="#fnref:SEP-0002" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:GeoSPARQLFunctions">
      <p><a href="https://github.com/opengeospatial/ogc-geosparql/blob/master/vocabularies/functions.ttl">https:/​/​github.com/opengeospatial/ogc-geosparql/blob/master/vocabularies/functions.ttl</a> <a href="#fnref:GeoSPARQLFunctions" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:extensionImplementation">
      <p><a href="https://github.com/smessie/TimeFunctions-SPARQL-Editor/blob/main/src/assets/queryWorker.ts">https:/​/​github.com/smessie/TimeFunctions-SPARQL-Editor/blob/main/src/assets/queryWorker.ts</a> <a href="#fnref:extensionImplementation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Yasqe">
      <p><a href="https://docs.triply.cc/yasgui-api/#yasqe">https:/​/​docs.triply.cc/yasgui-api/#yasqe</a> <a href="#fnref:Yasqe" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

      </div>
</section>

  <section id="genai" inlist="" rel="schema:hasPart" resource="#genai">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Declaration on Generative AI</h2>

        <p>During the preparation of this work, the author(s) used ChatGPT, DeepL in order to: Grammar and spelling check, Paraphrase and reword. After using this tool/service, the author(s) reviewed and edited the content as needed and take(s) full responsibility for the publication’s content.</p>

      </div>
</section>

<section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://www.w3.org/TR/2025/WD-rdf12-concepts-20250704/" typeof="schema:CreativeWork">Cyganiak, R., Wood, D., Lanthaler, M.: RDF 1.1 Concepts and Abstract Syntax. <a href="https://www.w3.org/TR/2025/WD-rdf12-concepts-20250704/">https:/​/​www.w3.org/TR/2025/WD-rdf12-concepts-20250704/</a> (2014).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#OperatorMapping" typeof="schema:CreativeWork">Harris, S., Seaborne, A.: SPARQL 1.1 Query Language. <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#OperatorMapping">https:/​/​www.w3.org/TR/2013/REC-sparql11-query-20130321/#OperatorMapping</a> (2013).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://www.w3.org/TR/timezone/" typeof="schema:CreativeWork">Phillips, A.: Working with Time and Timezones. <a href="https://www.w3.org/TR/timezone/">https:/​/​www.w3.org/TR/timezone/</a> (2024).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/" typeof="schema:CreativeWork">V. Biron, P., Malhotra, A.: XML Schema Part 2: Datatypes Second Edition. <a href="https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">https:/​/​www.w3.org/TR/2004/REC-xmlschema-2-20041028/</a> (2004).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="#soulard2025explainable" typeof="schema:Article">Soulard, T., Saı̈s Fatiha, Raad, J.: Explainable Temporal Fact Validation Through Constraints Discovery in Knowledge Graphs. In: European Semantic Web Conference. pp. 227–244. Springer (2025).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#de2016ontology" typeof="schema:Article">De Meester, B., Dimou, A., Verborgh, R., Mannens, E.: An ontology to semantically declare and describe functions. In: European Semantic Web Conference. pp. 46–49. Springer (2016).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
</dl>
</section>
</footer>


</div>



</body>
</html>
